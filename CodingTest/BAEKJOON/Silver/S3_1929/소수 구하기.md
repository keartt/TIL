# <img src="https://d2gd6pc034wcta.cloudfront.net/tier/8.svg" width="30" height="30" style="vertical-align: middle;"/> [1929] 소수 구하기
> [2024-06-20](https://www.acmicpc.net/problem/1929)

## Question
#### 문제
``` 
M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.
```
#### 입력
```
첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. 
(1 ≤ M ≤ N ≤ 1,000,000) M이상 N이하의 소수가 하나 이상 있는 입력만 주어진다.
```
#### 출력
```
한 줄에 하나씩, 증가하는 순서대로 소수를 출력한다.
```
### Tag
`수학`, `정수론`, `소수판정`, `에라토스테네스의 체`

--- 

## Answer2 [범위 내 소수 찾기] `(./Main.java)`
> [!tip] 
> 에라토스테네스의 체 이용
> index 와 수를 일치시키면 편함


| 메모리(kb) | 시간  (ms) | 시간복잡도 |
|---------|----------|-------|
| 32208   | 692       | $O(n * log(log n))$    |

### 왜 $N * \sqrt{\sqrt{N}}$ 이 아니라  $N * log(log N)$ 인가?
[거기까지는 생각하지말고 그냥 링크한번 보고 넘어가자;;;](https://en.wikipedia.org/wiki/Divergence_of_the_sum_of_the_reciprocals_of_the_primes)

## 에라토스테네스의 체
> 1~N 중 소수가 몇개인지 구할때 유용
> 낮은 시간복잡도  $O(n * log(log n))$
> 메모리 사용량이 큼, N 이 특정 수 이내일 경우 유용

1. 1 ~ N 까지 모든 수를 나열
2. 아직 처리하지 않은 가장 수 i 선택
3. 남은수 중 i 의 배수 모두 제거
4. 반복

```java
    static int howManyPrime(int num) {
        // index = 숫자 그 자체가 되게 하기 위해 쉽게 +1 추가함
        boolean[] notPrime = new boolean[num + 1];

        for (int i = 2; i <= Math.sqrt(num); i++) {
            if (notPrime[i]) continue;
            // 각 숫자의 배수가 있는지 체크함
            // 배수에 해당한다면 그 수는 소수가 아님
            for (int j = i * i; j <= num; j += i) {
                notPrime[j] = true; // 소수가 아닐경우 true
            }
        }

        int primeCount = 0;
        for (int i = 2; i < num + 1; i++) {
            if (!notPrime[i]) primeCount++;
//            i = 소수인 수
        }
        return primeCount;
    }
```